<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: incominginvite.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: incominginvite.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&apos;use strict&apos;;

var C = require(&apos;./util/constants&apos;);
var Conversation = require(&apos;./conversation&apos;);
var EventEmitter = require(&apos;events&apos;).EventEmitter;
var inherits = require(&apos;util&apos;).inherits;
var util = require(&apos;./util&apos;);

var LocalMedia = require(&apos;./media/localmedia&apos;);

/**
 * Construct an {@link IncomingInvite}.
 * @class
 * @classdesc An {@link IncomingInvite} to a {@link Conversation} can be accepted or
 * rejected.
 * &lt;br&gt;&lt;br&gt;
 * {@link IncomingInvite}s are returned by {@link Client#event:invite}.
 * @param {InviteServerTransaction} inviteServerTransaction - The
 *   {@link InviteServerTransaction} that this {@link IncomingInvite} wraps
 * @param {Object} [options] - Options to override the constructor&apos;s
 *   default behavior.
 * @property {Conversation.SID} conversationSid - The SID of the {@link Conversation}
 *   this {@link IncomingInvite} invites to
 * @property {string} from - The identity of the {@link Participant} that sent this
 *   {@link IncomingInvite}
 * @property {Array&lt;string&gt;} participants - The identities of the {@link Participant}s currently in the {@link Conversation}
 * @property {string} status - The status of this {@link IncomingInvite}, either
 *   &quot;accepting&quot;, &quot;accepted&quot;, &quot;rejected&quot;, &quot;canceled&quot;, &quot;failed&quot;, or &quot;pending&quot;
 * @fires IncomingInvite#accepted
 * @fires IncomingInvite#canceled
 * @fires IncomingInvite#failed
 * @fires IncomingInvite#rejected
 */
function IncomingInvite(inviteServerTransaction, options) {
  if (!(this instanceof IncomingInvite)) {
    return new IncomingInvite(inviteServerTransaction, options);
  }

  options = util.withDefaults({ }, options, {
    logLevel: C.DEFAULT_LOG_LEVEL
  });

  var self = this;
  EventEmitter.call(this);

  var conversation = null;
  var from = util.getUser(inviteServerTransaction.from);
  var getLocalMedia = null;
  var localMedia = null;
  var participants = [from];
  var participantSid = inviteServerTransaction.participantSid;
  var pending = 0;
  var shouldStopLocalMediaOnFailure = false;
  var status = &apos;pending&apos;;

  var deferred = util.defer();
  var inviteServerTransactions = new Set();
  inviteServerTransactions.add(inviteServerTransaction);

  /* istanbul ignore next */
  Object.defineProperties(this, {
    _conversation: {
      set: function(_conversation) {
        conversation = _conversation;
      },
      get: function() {
        return conversation;
      }
    },
    _deferred: {
      value: deferred
    },
    _getLocalMedia: {
      get: function() {
        return getLocalMedia;
      },
      set: function(_getLocalMedia) {
        getLocalMedia = _getLocalMedia;
      }
    },
    _inviteServerTransaction: {
      value: inviteServerTransaction
    },
    _inviteServerTransactions: {
      value: inviteServerTransactions
    },
    _localMedia: {
      get: function() {
        return localMedia;
      },
      set: function(_localMedia) {
        localMedia = _localMedia;
      }
    },
    _logLevel: {
      value: options.logLevel
    },
    _options: {
      get: function() {
        return options;
      },
      set: function(_options) {
        options = _options;
      }
    },
    _pending: {
      get: function() {
        return pending;
      },
      set: function(_pending) {
        pending = _pending;
      }
    },
    _promise: {
      value: deferred.promise
    },
    _shouldStopLocalMediaOnFailure: {
      get: function() {
        return shouldStopLocalMediaOnFailure;
      },
      set: function(_shouldStopLocalMediaOnFailure) {
        shouldStopLocalMediaOnFailure = _shouldStopLocalMediaOnFailure;
      }
    },
    _status: {
      get: function() {
        return status;
      },
      set: function(_status) {
        status = _status;
      }
    },
    conversationSid: {
      enumerable: true,
      value: inviteServerTransaction.conversationSid
    },
    from: {
      enumerable: true,
      value: from
    },
    participants: {
      enumerable: true,
      value: participants
    },
    participantSid: {
      enumerable: true,
      value: participantSid
    },
    status: {
      enumerable: true,
      get: function() {
        return status;
      }
    }
  });

  inviteServerTransaction.once(&apos;canceled&apos;, function() {
    self.emit(&apos;canceled&apos;, self);
  });

  return this;
}

inherits(IncomingInvite, EventEmitter);

IncomingInvite.prototype._onAcceptFailure = function _onAcceptFailure(reason) {
  this._pending--;

  if (this.status === &apos;accepting&apos; &amp;&amp; !this._pending) {
    this._status = &apos;failed&apos;;
    if (this._shouldStopLocalMediaOnFailure &amp;&amp; this._localMedia) {
      this._localMedia.stop();
    }
    this._deferred.reject(reason);
    this.emit(&apos;failed&apos;, this);
  }

  return this;
};

IncomingInvite.prototype._onDialog = function _onDialog(dialog) {
  this._pending--;

  var conversation
    = this._conversation
    = this._conversation || new Conversation(this._options);

  conversation._onDialog(dialog);

  if (this.status === &apos;accepting&apos;) {
    this._status = &apos;accepted&apos;;
    this._deferred.resolve(conversation);
    this.emit(&apos;accepted&apos;, this);
  }

  return conversation;
};

IncomingInvite.prototype._onInviteServerTransaction = function _onInviteServerTransaction(inviteServerTransaction) {
  var self = this;
  switch (this.status) {
    case &apos;canceled&apos;:
    case &apos;rejected&apos;:
      inviteServerTransaction.reject();
      return;
    case &apos;accepting&apos;:
      if (!this._inviteServerTransactions.has(inviteServerTransaction)) {
        this.participants.push(util.getUser(inviteServerTransaction.from));
        this._inviteServerTransactions.add(inviteServerTransaction);
      }
      this._pending++;
      this._getLocalMedia.then(function gotLocalMedia() {
        return inviteServerTransaction.accept(self._options);
      }).then(this._onDialog.bind(this), this._onAcceptFailure.bind(this));
      return;
    case &apos;accepted&apos;:
      this._conversation._onInviteServerTransaction(inviteServerTransaction);
      return;
    default:
      if (!this._inviteServerTransactions.has(inviteServerTransaction)) {
        this.participants.push(util.getUser(inviteServerTransaction.from));
        this._inviteServerTransactions.add(inviteServerTransaction);
      }
  }
};

/**
 * Accept the {@link IncomingInvite} and join the {@link Conversation}.
 * @param {IncomingInvite.AcceptOptions}
 *   [options={localStreamConstraints:{audio:true,video:true}}] - Options to override
 *   {@link IncomingInvite#accept}&apos;s default behavior
 * @fires IncomingInvite#accepted
 * @fires IncomingInvite#failed
 * @returns {Promise&lt;Conversation&gt;}
 * @example
 * var initialToken = getAccessToken();
 * var manager = new Twilio.AccessManager(initialToken);
 * var client = new Twilio.Conversations.Client(manager);
 *
 * client.on(&apos;invite&apos;, function(invite) {
 *   console.log(&apos;Received IncomingInvite to join a Conversation with &apos; + invite.from);
 *
 *   // By default, accept will request the microphone and camera for you.
 *   invite.accept();
 * });
 */
IncomingInvite.prototype.accept = function accept(options) {
  if (this.status === &apos;accepted&apos;) {
    return this._promise;
  }

  options = this._options = util.withDefaults({ }, options, this._options);
  this._status = &apos;accepting&apos;;

  var self = this;

  function getLocalMedia() {
    if (!options.localMedia &amp;&amp; !options.localStream) {
      self._shouldStopLocalMediaOnFailure = true;
      self._options.shouldStopLocalMediaOnDisconnect = true;
    }
    return LocalMedia.getLocalMedia(options);
  }

  this._getLocalMedia = getLocalMedia();

  return this._getLocalMedia.then(function gotLocalMedia(localMedia) {
    self._localMedia = localMedia;
    options.localMedia = localMedia;
    self._inviteServerTransactions.forEach(self._onInviteServerTransaction, self);
    return self._promise;
  });
};

/**
 * Reject the {@link IncomingInvite} to a {@link Conversation}.
 * @fires IncomingInvite#rejected
 * @example
 * var initialToken = getAccessToken();
 * var manager = new Twilio.AccessManager(initialToken);
 * var client = new Twilio.Conversations.Client(manager);
 *
 * client.on(&apos;invite&apos;, function(invite) {
 *   console.log(&apos;Rejecting IncomingInvite to join a Conversation with &apos; + invite.from);
 *   invite.reject();
 * });
 *
 * @returns {this}
 */
IncomingInvite.prototype.reject = function reject() {
  this._inviteServerTransactions.forEach(function(inviteServerTransaction) {
    inviteServerTransaction.reject();
  });
  this.emit(&apos;rejected&apos;);
  return this;
};

Object.freeze(IncomingInvite.prototype);

/**
 * The {@link IncomingInvite} was accepted, and the {@link Client} is now
 * participating in the {@link Conversation}.
 * @param {IncomingInvite} invite - The {@link IncomingInvite}
 * @event IncomingInvite#accepted
 */

/**
 * The {@link IncomingInvite} was rejected.
 * @param {IncomingInvite} invite - The {@link IncomingInvite}
 * @event IncomingInvite#rejected
 */

/**
 * The {@link IncomingInvite} was canceled.
 * @param {IncomingInvite} invite - The {@link IncomingInvite}
 * @event IncomingInvite#canceled
 */

/**
 * The {@link IncomingInvite} failed.
 * @param {IncomingInvite} invite - The {@link IncomingInvite}
 * @event IncomingInvite#failed
 */

/**
 * You may pass these options to {@link IncomingInvite#accept} to
 * override the default behavior.
 * @typedef {object} IncomingInvite.AcceptOptions
 * @property {?LocalMedia} [localMedia=null] - Set to reuse an existing
 *   {@link LocalMedia} object when accepting an {@link IncomingInvite}
 * @property {?MediaStream} [localStream=null] - Set to reuse an existing
 *   MediaStream when accepting an {@link IncomingInvite}
 * @property {?object} [localStreamConstraints={audio:true,video:true}] - Set to
 *   override the parameters passed to &lt;code&gt;getUserMedia&lt;/code&gt; when neither
 *   &lt;code&gt;localMedia&lt;/code&gt; nor &lt;code&gt;localStream&lt;/code&gt; are provided
 */

module.exports = IncomingInvite;
</code></pre>
        </article>
    </section>




</div>

<nav><h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html"><span style="color: #999">Twilio.Conversations.</span>Client</a><ul style="margin-left: 1em"><li><a href="IncomingInvite.html">IncomingInvite</a></li><li><a href="OutgoingInvite.html">OutgoingInvite</a></li></ul></li><li><a href="Conversation.html">Conversation</a><ul style="margin-left: 1em"><li><a href="Participant.html">Participant</a></li></ul></li><li><a href="Media.html">Media</a><ul style="margin-left: 1em"><li><a href="LocalMedia.html"><span style="color: #999">Twilio.Conversations.</span>LocalMedia</a></li><li><a href="LocalTrack.html">LocalTrack</a></li><li><a href="Track.html">Track</a><ul style="margin-left: 1em"><li><a href="AudioTrack.html">AudioTrack</a><ul style="margin-left: 1em"><li><a href="LocalAudioTrack.html">LocalAudioTrack</a></li></ul></li><li><a href="VideoTrack.html">VideoTrack</a><ul style="margin-left: 1em"><li><a href="LocalVideoTrack.html">LocalVideoTrack</a></li></ul></li></ul></li></ul></li></ul></nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Thu Feb 04 2016 04:15:51 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
