<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: client.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: client.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&apos;use strict&apos;;

var inherits = require(&apos;util&apos;).inherits;

var AccessManager = require(&apos;twilio-common&apos;).AccessManager;
var createCancelableRoomPromise = require(&apos;./cancelableroompromise&apos;);
var constants = require(&apos;./util/constants&apos;);
var Room = require(&apos;./room&apos;);
var E = require(&apos;./util/constants&apos;).twilioErrors;
var ECS = require(&apos;twilio-common/lib/ecs&apos;);
var EventEmitter = require(&apos;events&apos;).EventEmitter;
var LocalMedia = require(&apos;./media/localmedia&apos;);
var LocalParticipant = require(&apos;./localparticipant&apos;);
var Log = require(&apos;./util/log&apos;);
var SignalingV2 = require(&apos;./signaling/v2&apos;);
var TimeoutPromise = require(&apos;./util/timeoutpromise&apos;);
var util = require(&apos;./util&apos;);
var version = require(&apos;../package&apos;).version;

/**
 * Constructs a new {@link Client} with an Access Token string.
 * @class
 * @classdesc Construct a {@link Client} to start creating and connecting
 *   to {@link Room}s with other {@link Participant}s.
 * @param {string} token - The {@link Client}&apos;s Access Token string
 * @param {Client.ConstructorOptions} [options] - Options to override the
 *   constructor&apos;s default behavior
 * @property {?Date} tokenExpiration - The time at which the currently active Access
 *   Token will expire; this will not be populated until this information
 *   has been parsed and returned by the server.
 * @property {boolean} tokenIsExpired - Whether or not the currently active
 *   Access Token has expired; if tokenExpiration time is unknown, this is false.
 * @property {string} token - The {@link Client}&apos;s active Access Token
 * @property {Map&lt;Room.SID, Room&gt;} rooms - The {@link Room}s this
 *   {@link Client} is participating in
 * @fires Client#error
 * @fires Client#tokenExpired
 * @fires Client#tokenWillExpire
 */
function Client(token, options) {
  if (!(this instanceof Client)) {
    return new Client(token, options);
  }

  if (typeof token !== &apos;string&apos;) {
    throw E.INVALID_ARGUMENT.clone(&apos;&lt;string&gt; token is a required parameter&apos;);
  }

  EventEmitter.call(this);

  var accessManager = new AccessManager(token);
  var accountSid = accessManager._tokenPayload.sub;
  var identity = accessManager.identity;

  options = Object.assign({
    environment: constants.DEFAULT_ENVIRONMENT,
    logLevel: constants.DEFAULT_LOG_LEVEL,
    realm: constants.DEFAULT_REALM,
    signaling: SignalingV2
  }, options);

  /* eslint new-cap:0 */
  options = Object.assign({
    ecsServer: constants.ECS_SERVER(options.environment, options.realm),
    wsServer: constants.WS_SERVER(options.environment, options.realm, accountSid)
  }, options);

  var defaultIceServers = constants.DEFAULT_ICE_SERVERS(options.environment);
  var logLevel = options.logLevel;
  var log = new Log(&apos;Client&apos;, logLevel);
  var rooms = new Map();
  var self = this;
  var Signaling = options.signaling;
  var signaling = new Signaling(options.wsServer, accountSid, identity, options);

  accessManager.on(&apos;tokenExpired&apos;, function() {
    self.emit(&apos;tokenExpired&apos;);
  });

  accessManager.on(&apos;tokenWillExpire&apos;, function() {
    self.emit(&apos;tokenWillExpire&apos;);
  });

  function getConfiguration() {
    return ECS.getConfiguration(accessManager.token, {
      configUrl: options.ecsServer + &apos;/v1/Configuration&apos;,
      body: {
        &apos;service&apos;: &apos;rtc&apos;,
        &apos;sdk_version&apos;: version
      }
    }).then(function(res) {
      var ttl = util.getOrNull(res, &apos;rtc.network_traversal_service.ttl&apos;);
      ttl = ttl || constants.ICE_SERVERS_DEFAULT_TTL;

      setTimeout(function renewIceServers() {
        self._ecsPromise = getConfiguration();
      }, (ttl - constants.ECS_TIMEOUT) * 1000);

      return res;
    }, function(reason) {
      log.warn(&apos;Failed to fetch Endpoint Configuration: &apos; + reason);
      return null;
    });
  }

  /* istanbul ignore next */
  Object.defineProperties(this, {
    _accessManager: {
      value: accessManager
    },
    _defaultIceServers: {
      value: defaultIceServers
    },
    _ecsPromise: {
      value: getConfiguration(),
      writable: true
    },
    _log: {
      value: log
    },
    _options: {
      value: options
    },
    _rooms: {
      value: rooms
    },
    _signaling: {
      value: signaling
    },
    rooms: {
      enumerable: true,
      get: function() {
        return new Map(rooms);
      }
    },
    token: {
      enumerable: true,
      get: function() {
        return accessManager.token;
      }
    },
    tokenExpiration: {
      enumerable: true,
      get: function() {
        return accessManager.expires;
      }
    },
    tokenIsExpired: {
      enumerable: true,
      get: function() {
        return accessManager.isExpired;
      }
    }
  });
}

inherits(Client, EventEmitter);

/**
 * Connect to a {@link Room}.
 *   &lt;br&gt;&lt;br&gt;
 *   By default, this will automatically acquire {@link LocalMedia} containing a
 *   {@link LocalAudioTrack} and {@link LocalVideoTrack} before connecting to the
 *   {@link Room}. The {@link LocalMedia} will be stopped when you disconnect
 *   from the {@link Room}.
 *   &lt;br&gt;&lt;br&gt;
 *   You can override the default behavior by specifying
 *   &lt;code&gt;options&lt;/code&gt;. For example, rather than acquiring {@link LocalMedia}
 *   automatically, you can pass your own instance which you can stop yourself.
 *   See {@link Client.ConnectOptions} for more information.
 * @param {Client.ConnectOptions}
 *   [options={audio:true,video:true}] - Options to override
 *   the default behavior
 * @returns {CancelablePromise&lt;Room&gt;}
 * @example
 * var initialToken = getAccessToken();
 * var client = new Twilio.Video.Client(initialToken);
 *
 * client.connect({ to: my-cool-room&apos; }).then(function(room) {
 *   room.on(&apos;participantConnected&apos;, function(participant) {
 *     console.log(participant.identity + &apos; has connected&apos;);
 *   });
 * });
 * @example
 * var initialToken = getAccessToken();
 * var client = new Twilio.Video.Client(initialToken);
 *
 * var localMedia = new Twilio.Video.LocalMedia();
 *
 * // Connect with audio-only
 * localMedia.addMicrophone().then(function() {
 *   return client.connect({ to: &apos;my-cool-room&apos;, localMedia: localMedia });
 * }).then(function(room) {
 *   // Our LocalParticipant reuses the LocalMedia we passed in.
 *   room.localParticipant.media === localMedia; // true
 *
 *   room.on(&apos;participantConnected&apos;, function(participant) {
 *     console.log(participant.identity + &apos; has connected&apos;);
 *   });
 *
 *   // Make sure to stop localMedia
 *   room.once(&apos;disconnected&apos;, function() {
 *     localMedia.stop();
 *   });
 * });
 */
Client.prototype.connect = function connect(options) {
  options = Object.assign({
    create: true,
    to: null
  }, this._options, options);
  return createCancelableRoomPromise(
    getLocalMedia.bind(null, this, options),
    createLocalParticipant.bind(null, this),
    createRoomSignaling.bind(null, this, options),
    createRoom.bind(null, this, options));
};

/**
 * Replace the {@link Client}&apos;s currently active token with a new token.
 * @param {string} newToken - The new token to use to authenticate this {@link Client}.
 * @returns {Promise&lt;this&gt;}
 * @example
 * var initialToken = getAccessToken();
 * var client = new Twilio.Video.Client(initialToken);
 *
 * client.on(&apos;tokenWillExpire&apos;, function() {
 *   var newToken = getAccessToken();
 *
 *   client.updateToken(newToken).then(function() {
 *     console.info(&apos;Successfully updated with new token&apos;);
 *   }, function(reason) {
 *     console.error(&apos;Error while updating token: &apos; + reason);
 *   });
 * });
 */
Client.prototype.updateToken = function updateToken(newToken) {
  var self = this;
  return this._accessManager.updateToken(newToken).then(function() {
    return self;
  });
};

/**
 * Your {@link Client} has run into an error.
 * @param {Error} error - The Error
 * @event Client#error
 * @example
 * var initialToken = getAccessToken();
 * var client = new Twilio.Video.Client(initialToken);
 *
 * client.on(&apos;error&apos;, function(error) {
 *  console.error(error);
 * });
 */

/**
 * The active Access Token has expired.
 * @event Client#tokenExpired
 * @example
 * var initialToken = getAccessToken();
 * var client = new Twilio.Video.Client(initialToken);
 *
 * client.on(&apos;tokenExpired&apos;, function() {
 *   console.error(&apos;Uh oh! Token has expired.&apos;);
 * });
 */

/**
 * The active Access Token will expire soon.
 * @event Client#tokenWillExpire
 * @example
 * var initialToken = getAccessToken();
 * var client = new Twilio.Video.Client(initialToken);
 *
 * client.on(&apos;tokenWillExpire&apos;, function() {
 *   var newToken = getAccessToken();
 *
 *   client.updateToken(newToken).then(function() {
 *     console.info(&apos;Successfully updated with new token&apos;);
 *   }, function(reason) {
 *     console.error(&apos;Error while updating token: &apos; + reason);
 *   });
 * });
 */

/**
 * You may pass these options to {@link Client}&apos;s constructor to override
 * its default behavior.
 * @typedef {object} Client.ConstructorOptions
 * @property {Array&lt;RTCIceServer&gt;} iceServers - Override the STUN and TURN
 *   servers used by the {@link Client} when connecting to {@link Room}s
 * @property {RTCIceTransportPolicy} [iceTransportPolicy=&quot;all&quot;] - Override the ICE
 *   transport policy to be one of &quot;relay&quot; or &quot;all&quot;
 * @property {string} [logLevel=&apos;warn&apos;] - Set the verbosity of logging to console.
 *   Valid values: [&apos;off&apos;, &apos;error&apos;, &apos;warn&apos;, &apos;info&apos;, &apos;debug&apos;]
 */

/**
 * You may pass these options to {@link Client#connect} to
 * override the default behavior.
 * @typedef {object} Client.ConnectOptions
 * @property {?boolean} [audio=true] - Whether or not to get local audio
 *   with &lt;code&gt;getUserMedia&lt;/code&gt; when neither &lt;code&gt;localMedia&lt;/code&gt;
 *   nor &lt;code&gt;localStream&lt;/code&gt; are provided
 * @property {?boolean} [create=true] - Set to false in order to only connect
 *   to a {@link Room} if it already exists (use in conjunction with
 *   &lt;code&gt;to&lt;/code&gt;)
 * @property {Array&lt;RTCIceServer&gt;} iceServers - Override the STUN and TURN
 *   servers used by the {@link Client} when connecting to {@link Room}s
 * @property {RTCIceTransportPolicy} [iceTransportPolicy=&quot;all&quot;] - Override the ICE
 *   transport policy to be one of &quot;relay&quot; or &quot;all&quot;
 * @property {?LocalMedia} [localMedia=null] - Set to reuse an existing
 *   {@link LocalMedia} object when creating the {@link Room}
 * @property {?MediaStream} [localStream=null] - Set to reuse an existing
 *   &lt;code&gt;MediaStream&lt;/code&gt; when creating the {@link Room}
 * @property {?string} [to=null] - Set to connect to a {@link Room} by name
 * @property {?boolean} [video=true] - Whether or not to get local video
 *   with &lt;code&gt;getUserMedia&lt;/code&gt; when neither &lt;code&gt;localMedia&lt;/code&gt;
 *   nor &lt;code&gt;localStream&lt;/code&gt; are provided
 */

function createLocalParticipant(client, localMedia) {
  var signaling = client._signaling.createLocalParticipantSignaling();
  return new LocalParticipant(signaling, localMedia);
}

function createRoom(client, options, localParticipant, roomSignaling) {
  var room = new Room(localParticipant, roomSignaling, options);
  client._rooms.set(room.sid, room);

  roomSignaling.on(&apos;stateChanged&apos;, function stateChanged() {
    client._rooms.delete(room.sid);
    roomSignaling.removeListener(&apos;stateChanged&apos;, stateChanged);
  });

  return room;
}

function createRoomSignaling(client, options, localParticipant) {
  return getIceServers(client, options).then(function(iceServers) {
    options.iceServers = iceServers;
    return client._signaling.connect(
      localParticipant._signaling,
      client._accessManager.token,
      client._accessManager._tokenPayload.sub,
      client._accessManager.identity,
      options);
  });
}

function getLocalMedia(client, options, handleLocalMedia) {
  options.shouldStopLocalMedia = !options.localMedia &amp;&amp; !options.localStream;
  return LocalMedia.getLocalMedia(options).then(function getLocalMediaSucceeded(localMedia) {
    var promise = handleLocalMedia(localMedia);
    promise.catch(function handleLocalMediaFailed() {
      if (options.shouldStopLocalMedia) {
        localMedia.stop();
      }
    });
    return promise;
  });
}

function getIceServers(client, options) {
  var log = client._log;

  if (options.iceServers) {
    return Promise.resolve(options.iceServers);
  }

  return new TimeoutPromise(client._ecsPromise, constants.ICE_SERVERS_TIMEOUT_MS).then(function(config) {
    var nts = util.getOrNull(config, &apos;rtc.network_traversal_service&apos;);

    if (!nts) {
      throw new Error(&apos;network_traversal_service not available&apos;);
    }

    if (nts.warning) {
      log.warn(nts.warning);
    }

    if (!nts.ice_servers) {
      throw new Error(&apos;ice_servers not available&apos;);
    }

    return nts.ice_servers;
  }).catch(function(reason) {
    log.warn(&apos;Failed to fetch ice servers from ECS: &apos; + reason.message);
    return client._defaultIceServers;
  });
}

module.exports = Client;
</code></pre>
        </article>
    </section>




</div>

<nav><h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AudioTrack.html">AudioTrack</a></li><li><a href="Client.html">Client</a></li><li><a href="LocalAudioTrack.html">LocalAudioTrack</a></li><li><a href="LocalMedia.html">LocalMedia</a></li><li><a href="LocalParticipant.html">LocalParticipant</a></li><li><a href="LocalTrack.html">LocalTrack</a></li><li><a href="LocalVideoTrack.html">LocalVideoTrack</a></li><li><a href="Media.html">Media</a></li><li><a href="Participant.html">Participant</a></li><li><a href="Room.html">Room</a></li><li><a href="Track.html">Track</a></li><li><a href="VideoTrack.html">VideoTrack</a></li></ul></nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Tue Aug 23 2016 16:34:30 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-2900316-33', 'auto');ga('send', 'pageview');</script></body>
</html>
