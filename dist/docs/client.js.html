<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: client.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: client.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&apos;use strict&apos;;

var inherits = require(&apos;util&apos;).inherits;

var AccessManager = require(&apos;twilio-common&apos;).AccessManager;
var constants = require(&apos;./util/constants&apos;);
var Conversation = require(&apos;./conversation&apos;);
var EventEmitter = require(&apos;events&apos;).EventEmitter;
var IncomingInvite = require(&apos;./incominginvite&apos;);
var LocalMedia = require(&apos;./media/localmedia&apos;);
var Log = require(&apos;./util/log&apos;);
var OutgoingInvite = require(&apos;./outgoinginvite&apos;);
var SignalingV1 = require(&apos;./signaling/v1&apos;);
var SignalingV2 = require(&apos;./signaling/v2&apos;);

/**
 * Constructs a new {@link Client} with an AccessManager. Alternatively, you
 * can pass an Access Token string and the {@link Client} will construct an
 * AccessManager for you. AccessManager is provided by twilio-common.js, which
 * must be included alongside twilio-conversations.js.
 * @class
 * @classdesc Construct a {@link Client} to start creating and participating
 *   in {@link Conversation}s with other {@link Participant}s.
 * @param {AccessManager|string} managerOrToken - The {@link Client}&apos;s AccessManager or an Access Token string to use when constructing an AccessManager
 * @param {Client.ConstructorOptions} [options] - Options to override the
 *   constructor&apos;s default behavior
 * @property {AccessManager} accessManager - The {@link Client}&apos;s AccessManager
 * @property {string} identity - The {@link Client}&apos;s identity
 * @property {Map&lt;Conversation.SID, Conversation&gt;} conversations - The {@link Conversation}s this
 *   {@link Client} is participating in
 * @property {bool} isListening - Whether the {@link Client} is listening for
 *   {@link IncomingInvite}s to {@link Conversation}s
 * @fires Client#invite
 * @fires Client#error
 */
function Client(accessManager, options) {
  if (!(this instanceof Client)) {
    return new Client(accessManager, options);
  }

  if (typeof accessManager === &apos;string&apos;) {
    accessManager = new AccessManager(accessManager);
  }

  EventEmitter.call(this);

  options = Object.assign({
    logLevel: constants.DEFAULT_LOG_LEVEL,
    signaling: &apos;v1&apos;
  }, options);

  var Signaling;
  switch (options.signaling) {
    case &apos;v1&apos;:
      Signaling = SignalingV1;
      break;
    case &apos;v2&apos;:
      Signaling = SignalingV2;
      break;
    default:
      if (typeof options.signaling === &apos;function&apos;) {
        Signaling = options.signaling;
      }
      throw new Error(
        &apos;Unknown Signaling version &quot;&apos; + options.signaling + &apos;&quot;&apos;);
  }

  var conversations = new Map();
  var logLevel = options.logLevel;
  var log = new Log(&apos;Client&apos;, logLevel);
  var signaling = new Signaling(accessManager, options);

  /* istanbul ignore next */
  Object.defineProperties(this, {
    _conversations: {
      value: conversations
    },
    _log: {
      value: log
    },
    _signaling: {
      value: signaling
    },
    accessManager: {
      enumerable: true,
      value: accessManager
    },
    conversations: {
      enumerable: true,
      get: function() {
        return new Map(conversations);
      }
    },
    identity: {
      enumerable: true,
      get: function() {
        return accessManager.identity;
      }
    },
    isListening: {
      enumerable: true,
      get: function() {
        return signaling.state === &apos;listening&apos;;
      }
    }
  });

  handleSignalingEvents(this, signaling);
}

inherits(Client, EventEmitter);

/**
 * Causes this {@link Client} to stop listening for {@link IncomingInvite}s to
 *   {@link Conversation}s until {@link Client#listen} is called again.
 * @returns {this}
 */
Client.prototype.unlisten = function unlisten() {
  this._signaling.unlisten();
  return this;
};

/**
 * Causes this {@link Client} to start listening for {@link IncomingInvite}s to
 *   {@link Conversation}s.
 * @returns {Promise&lt;this&gt;}
 * @example
 * var initialToken = getAccessToken();
 * var manager = new Twilio.AccessManager(initialToken);
 * var alice = new Twilio.Conversations.Client(manager);
 *
 * alice.listen().then(function() {
 *   console.log(&apos;Alice is listening&apos;);
 * }, function(error) {
 *   console.error(error);
 * });
 */
Client.prototype.listen = function listen() {
  var self = this;
  return this._signaling.listen().then(function listenSucceeded() {
    return self;
  });
};

/**
 * Invite remote {@link Client}s to join a {@link Conversation}.
 *   &lt;br&gt;&lt;br&gt;
 *   By default, this will attempt to setup an {@link AudioTrack} and
 *   {@link VideoTrack} between local and remote {@link Client}s. You can
 *   override this by specifying &lt;code&gt;options&lt;/code&gt;.
 * @param {Array&lt;string&gt;|string} participants - {@link Participant} identities to invite to the {@link Conversation}
 * @param {Client.InviteToConversationOptions}
 *   [options={localStreamConstraints:{audio:true,video:true}}] - Options to override
 *   {@link Client#inviteToConversation}&apos;s default behavior
 * @returns {OutgoingInvite}
 * @example
 * var initialToken = getAccessToken();
 * var manager = new Twilio.AccessManager(initialToken);
 * var client = new Twilio.Conversations.Client(manager);
 *
 * client.inviteToConversation([&apos;bob&apos;, &apos;charlie&apos;]).then(function(conversation) {
 *   conversation.on(&apos;participantConnected&apos;, function(participant) {
 *     console.log(participant.identity + &apos; has connected&apos;);
 *   });
 * });
 */
Client.prototype.inviteToConversation = function inviteToConversation(identities, options) {
  identities = identities || [];
  identities = identities instanceof Array ? identities : [identities];
  options = Object.assign({}, this._options, options);
  var labelOrSid = options.labelOrSid;
  return new OutgoingInvite(identities,
    getLocalMedia.bind(null, this, options),
    createOutgoingInviteSignaling.bind(null, this, identities, labelOrSid, options),
    createConversation.bind(null, this, options));
};

/**
 * Your {@link Client} has run into an error.
 * @param {Error} error - The Error
 * @event Client#error
 * @example
 * var initialToken = getAccessToken();
 * var manager = new Twilio.AccessManager(initialToken);
 * var client = new Twilio.Conversations.Client(manager);
 *
 * client.on(&apos;error&apos;, function(error) {
 *  console.error(error);
 * });
 */

/**
 * Your {@link Client} has received an {@link IncomingInvite} to participant in a
 * {@link Conversation}.
 * @param {IncomingInvite} invite - the {@link IncomingInvite}
 * @event Client#invite
 * @example
 * var initialToken = getAccessToken();
 * var manager = new Twilio.AccessManager(initialToken);
 * var client = new Twilio.Conversations.Client(manager);
 *
 * client.on(&apos;invite&apos;, function(invite) {
 *   console.log(&apos;Received an IncomingInvite to join a Conversation from &apos; + invite.from);
 * });
 */

/**
 * You may pass these options to {@link Client}&apos;s constructor to override
 * its default behavior.
 * @typedef {object} Client.ConstructorOptions
 * @property {Array&lt;RTCIceServer&gt;} iceServers - Override the STUN and TURN
 *   servers used by the {@link Client} when connecting to {@link Conversation}s
 * @property {RTCIceTransportPolicy} [iceTransportPolicy=&quot;all&quot;] - Override the ICE
 *   transport policy to be one of &quot;relay&quot; or &quot;all&quot;
 * @property {string} [logLevel=&apos;warn&apos;] - Set the verbosity of logging to console.
 *   Valid values: [&apos;off&apos;, &apos;error&apos;, &apos;warn&apos;, &apos;info&apos;, &apos;debug&apos;]
 */

/**
 * You may pass these options to {@link Client#inviteToConversation} to
 * override the default behavior.
 * @typedef {object} Client.InviteToConversationOptions
 * @property {Array&lt;RTCIceServer&gt;} iceServers - Override the STUN and TURN
 *   servers used by the {@link Client} when connecting to {@link Conversation}s
 * @property {RTCIceTransportPolicy} [iceTransportPolicy=&quot;all&quot;] - Override the ICE
 *   transport policy to be one of &quot;relay&quot; or &quot;all&quot;
 * @property {?LocalMedia} [localMedia=null] - Set to reuse an existing
 *   {@link LocalMedia} object when creating the {@link Conversation}
 * @property {?MediaStream} [localStream=null] - Set to reuse an existing
 *   &lt;code&gt;MediaStream&lt;/code&gt; when creating the {@link Conversation}
 * @property {?object} [localStreamConstraints={audio:true,video:true}] - Set to
 *   override the parameters passed to &lt;code&gt;getUserMedia&lt;/code&gt; when neither
 *   &lt;code&gt;localMedia&lt;/code&gt; nor &lt;code&gt;localStream&lt;/code&gt; are provided
 */

function createConversation(client, options, conversationSignaling) {
  var conversation = new Conversation(conversationSignaling, options);
  client._conversations.set(conversation.sid, conversation);

  conversationSignaling.on(&apos;stateChanged&apos;, function stateChanged() {
    client._conversations.delete(conversation.sid);
    conversationSignaling.removeListener(&apos;stateChanged&apos;, stateChanged);
  });

  return conversation;
}

function createOutgoingInviteSignaling(client, identities, labelOrSid, options, localMedia) {
  return client._signaling.connect(identities, labelOrSid, localMedia, options);
}

function getLocalMedia(client, options, handleLocalMedia) {
  options.shouldStopLocalMedia = !options.localMedia &amp;&amp; !options.localStream;
  return LocalMedia.getLocalMedia(options).then(function getLocalMediaSucceeded(localMedia) {
    var promise = handleLocalMedia(localMedia);
    promise.catch(function handleLocalMediaFailed() {
      if (options.shouldStopLocalMedia) {
        localMedia.stop();
      }
    });
    return promise;
  });
}

function handleSignalingEvents(client, signaling) {
  signaling.on(&apos;invite&apos;, function invite(incomingInviteSignaling) {
    var incomingInvite = new IncomingInvite(incomingInviteSignaling,
      getLocalMedia.bind(null, client),
      createConversation.bind(null, client),
      client._options);

    client.emit(&apos;invite&apos;, incomingInvite);
  });
}

module.exports = Client;
</code></pre>
        </article>
    </section>




</div>

<nav><h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html"><span style="color: #999">Twilio.Conversations.</span>Client</a><ul style="margin-left: 1em"><li><a href="IncomingInvite.html">IncomingInvite</a></li><li><a href="OutgoingInvite.html">OutgoingInvite</a></li></ul></li><li><a href="Conversation.html">Conversation</a><ul style="margin-left: 1em"><li><a href="Participant.html">Participant</a></li></ul></li><li><a href="Media.html">Media</a><ul style="margin-left: 1em"><li><a href="LocalMedia.html"><span style="color: #999">Twilio.Conversations.</span>LocalMedia</a></li><li><a href="LocalTrack.html">LocalTrack</a></li><li><a href="Track.html">Track</a><ul style="margin-left: 1em"><li><a href="AudioTrack.html">AudioTrack</a><ul style="margin-left: 1em"><li><a href="LocalAudioTrack.html">LocalAudioTrack</a></li></ul></li><li><a href="VideoTrack.html">VideoTrack</a><ul style="margin-left: 1em"><li><a href="LocalVideoTrack.html">LocalVideoTrack</a></li></ul></li></ul></li></ul></li></ul></nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Mon Oct 03 2016 18:25:01 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-2900316-33', 'auto');ga('send', 'pageview');</script></body>
</html>
