<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: outgoinginvite.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: outgoinginvite.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&apos;use strict&apos;;

var EventEmitter = require(&apos;events&apos;).EventEmitter;
var inherits = require(&apos;util&apos;).inherits;
var util = require(&apos;./util&apos;);

/**
 * Construct an {@link OutgoingInvite}.
 * @class
 * @classdesc An {@link OutgoingInvite} is a Promise that eventually resolves
 *   to a {@link Conversation} if one or more {@link Participant}s accept the
 *   corresponding {@link IncomingInvite}. An {@link OutgoingInvite} may be
 *   canceled up until a {@link Participant} has accepted it.
 *   &lt;br&gt;&lt;br&gt;
 *   {@link OutgoingInvite}s are returned by {@link Client#inviteToConversation}.
 * @extends Promise&lt;Conversation&gt;
 * @param {Array&lt;string&gt;} identities
 * @param {function(function(LocalMedia): Promise&lt;OutgoingInvite&gt;): Promise&lt;OutgoingInvite&gt;} getLocalMedia
 * @param {function(LocalMedia): Promise&lt;OutgoingInviteSignaling&gt;} createOutgoingInviteSignaling
 * @param {function(ConversationSignaling): Conversation} createConversation
 * @property {string} status - The status of this {@link OutgoingInvite}, either
 *   &quot;accepted&quot;, &quot;rejected&quot;, &quot;canceled&quot;, &quot;failed&quot;, or &quot;pending&quot;
 * @property {Array&lt;string&gt;} to - The {@link Participant} identities
 *   invited by this {@link OutgoingInvite}
 * @fires OutgoingInvite#accepted
 * @fires OutgoingInvite#canceled
 * @fires OutgoingInvite#failed
 * @fires OutgoingInvite#rejected
 */
function OutgoingInvite(identities, getLocalMedia, createOutgoingInviteSignaling, createConversation) {
  if (!(this instanceof OutgoingInvite)) {
    return new OutgoingInvite(identities, getLocalMedia, createOutgoingInviteSignaling, createConversation);
  }
  EventEmitter.call(this);
  Object.defineProperties(this, {
    _deferred: {
      value: util.defer()
    },
    _isCanceled: {
      writable: true,
      value: false
    },
    _isFailed: {
      writable: true,
      value: false
    },
    _signaling: {
      writable: true,
      value: null
    },
    status: {
      enumerable: true,
      get: function() {
        if (this._isCanceled) {
          return &apos;canceled&apos;;
        } else if (this._isFailed) {
          return &apos;failed&apos;;
        } else if (this._signaling) {
          return this._signaling.state;
        }
        return &apos;pending&apos;;
      }
    },
    to: {
      enumerable: true,
      get: function() {
        return identities.slice();
      }
    }
  });

  var cancelationError = new Error(&apos;Canceled&apos;);

  function cancel(signaling) {
    if (signaling) {
      // Try canceling the OutgoingInviteSignaling, and
      signaling.cancel();

      // Just in case it was already accepted, disconnect the ConversationSignaling,
      // should it ever resolve.
      signaling.getConversationSignaling().then(function connectSucceeded(conversationSignaling) {
        conversationSignaling.disconnect();
      });
    }

    throw cancelationError;
  }

  var self = this;
  getLocalMedia(function getLocalMediaSucceeded(localMedia) {
    if (self.status === &apos;canceled&apos;) {
      cancel();
    }
    return createOutgoingInviteSignaling(localMedia).then(function outgoingInviteSignalingCreated(signaling) {
      if (self.status === &apos;canceled&apos;) {
        cancel(signaling);
      }
      self._signaling = signaling;
      handleSignalingEvents(self, signaling);
      return signaling.getConversationSignaling();
    });
  }).then(function outgoingInviteSignalingAccepted(conversationSignaling) {
    self._deferred.resolve(createConversation(conversationSignaling));
  }).catch(function onError(error) {
    if (error !== cancelationError) {
      self._isFailed = true;
      if (!self._signaling) {
        self.emit(&apos;failed&apos;, self);
      }
      self._deferred.reject(error);
    }
  });
}

inherits(OutgoingInvite, EventEmitter);

/**
 * Attempt to cancel the {@link OutgoingInvite}.
 * @returns {this}
 */
OutgoingInvite.prototype.cancel = function cancel() {
  if (this._signaling) {
    this._signaling.cancel();
    return this;
  }
  this._isCanceled = true;
  this.emit(&apos;canceled&apos;, this);
  this._deferred.reject(new Error(&apos;OutgoingInvite canceled&apos;));
  return this;
};

OutgoingInvite.prototype.catch = function _catch() {
  return this._deferred.promise.catch.apply(this._deferred.promise, arguments);
};

OutgoingInvite.prototype.then = function then() {
  return this._deferred.promise.then.apply(this._deferred.promise, arguments);
};

function handleSignalingEvents(outgoingInvite, signaling) {
  // Reemit state transition events from the OutgoingInviteSignaling.
  signaling.on(&apos;stateChanged&apos;, function stateChanged(state) {
    outgoingInvite.emit(state, outgoingInvite);
  });
}

/**
 * The {@link OutgoingInvite} was accepted, and the {@link Client} is now
 * participating in the {@link Conversation}.
 * @param {OutgoingInvite} invite - The {@link OutgoingInvite}
 * @event OutgoingInvite#accepted
 */

/**
 * The {@link OutgoingInvite} was rejected.
 * @param {OutgoingInvite} invite - The {@link OutgoingInvite}
 * @event OutgoingInvite#rejected
 */

/**
 * The {@link OutgoingInvite} was canceled.
 * @param {OutgoingInvite} invite - The {@link OutgoingInvite}
 * @event OutgoingInvite#canceled
 */

/**
 * The {@link OutgoingInvite} failed.
 * @param {OutgoingInvite} invite - The {@link OutgoingInvite}
 * @event OutgoingInvite#failed
 */

module.exports = OutgoingInvite;
</code></pre>
        </article>
    </section>




</div>

<nav><h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html"><span style="color: #999">Twilio.Conversations.</span>Client</a><ul style="margin-left: 1em"><li><a href="IncomingInvite.html">IncomingInvite</a></li><li><a href="OutgoingInvite.html">OutgoingInvite</a></li></ul></li><li><a href="Conversation.html">Conversation</a><ul style="margin-left: 1em"><li><a href="Participant.html">Participant</a></li></ul></li><li><a href="Media.html">Media</a><ul style="margin-left: 1em"><li><a href="LocalMedia.html"><span style="color: #999">Twilio.Conversations.</span>LocalMedia</a></li><li><a href="LocalTrack.html">LocalTrack</a></li><li><a href="Track.html">Track</a><ul style="margin-left: 1em"><li><a href="AudioTrack.html">AudioTrack</a><ul style="margin-left: 1em"><li><a href="LocalAudioTrack.html">LocalAudioTrack</a></li></ul></li><li><a href="VideoTrack.html">VideoTrack</a><ul style="margin-left: 1em"><li><a href="LocalVideoTrack.html">LocalVideoTrack</a></li></ul></li></ul></li></ul></li></ul></nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Mon Jul 18 2016 22:47:05 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-2900316-33', 'auto');ga('send', 'pageview');</script></body>
</html>
